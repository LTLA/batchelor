% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rescaleBatches.R
\name{rescaleBatches}
\alias{rescaleBatches}
\title{Scale counts across batches}
\usage{
rescaleBatches(..., batch = NULL, restrict = NULL, log.base = 2,
  pseudo.count = 1, subset.row = NULL, assay.type = "logcounts",
  get.spikes = FALSE)
}
\arguments{
\item{...}{Two or more log-expression matrices where genes correspond to rows and cells correspond to columns.
Each matrix should contain the same number of rows, corresponding to the same genes (in the same order).

Alternatively, one or more \linkS4class{SingleCellExperiment} objects can be supplied containing a count matrix in the \code{assay.type} assay.
Note the same restrictions described above for gene expression matrix inputs.

If multiple objects are supplied, each object is assumed to contain all and only cells from a single batch.
Objects of different types can be mixed together. 
If a single object is supplied, \code{batch} should also be specified.}

\item{batch}{A factor specifying the batch of origin for all cells when only a single object is supplied in \code{...}.
This is ignored if multiple objects are present.}

\item{restrict}{A list of length equal to the number of objects in \code{...}.
Each entry of the list corresponds to one batch and specifies the cells to use when computing the correction.}

\item{log.base}{A numeric scalar specifying the base of the log-transformation.}

\item{pseudo.count}{A numeric scalar specifying the pseudo-count used for the log-transformation.}

\item{subset.row}{A vector specifying which features to use for correction.}

\item{assay.type}{A string or integer scalar specifying the assay containing the log-expression values, if SingleCellExperiment objects are present in \code{...}.}

\item{get.spikes}{Deprecated, a logical scalar indicating whether to retain rows corresponding to spike-in transcripts.
Only used for SingleCellExperiment inputs.}
}
\value{
A \linkS4class{SingleCellExperiment} object containing the \code{corrected} assay.
This contains corrected log-expression values for each gene (row) in each cell (column) in each batch.
A \code{batch} field is present in the column data, specifying the batch of origin for each cell.

Cells in the output object are always ordered in the same manner as supplied in \code{...}.
For a single input object, cells will be reported in the same order as they are arranged in that object.
In cases with multiple input objects, the cell identities are simply concatenated from successive objects,
i.e., all cells from the first object (in their provided order), then all cells from the second object, and so on.
}
\description{
Scale counts so that the average count within each batch is the same for each gene.
}
\details{
This function assumes that the log-expression values were computed by a log-transformation of normalized count data, plus a pseudo-count.
It reverses the log-transformation and scales the underlying counts in each batch so that the average (normalized) count is equal across batches.
The assumption here is that each batch contains the same population composition.
Thus, any scaling difference between batches is technical and must be removed.

This function is equivalent to centering in log-expression space, the simplest application of linear regression methods for batch correction.
However, by scaling the raw counts, it avoids loss of sparsity that would otherwise result from centering.
It also mitigates issues with artificial differences in variance due to log-transformation.

The output values are always re-log-transformed with the same \code{log.base} and \code{pseudo.count}.
These can be used directly in place of the input values for downstream operations.

All genes are used with the default setting of \code{subset.row=NULL}.
Users can set \code{subset.row} to subset the inputs, though this is purely for convenience as each gene is processed independently of other genes.
}
\section{Using restriction}{

It is possible to compute the correction using only a subset of cells in each batch, and then extrapolate that correction to all other cells.
This may be desirable in experimental designs where a control set of cells from the same source population were run on different batches.
Any difference in the controls must be artificial in origin and can be directly removed without making further biological assumptions.

To do this, users should set \code{restrict} to specify the subset of cells in each batch to be used for correction.
This should be set to a list of length equal to the length of \code{...}, where each element is a subsetting vector to be applied to the columns of the corresponding batch.
A \code{NULL} element indicates that all the cells from a batch should be used.
In situations where one input object contains multiple batches, \code{restrict} is simply a list containing a single subsetting vector for that object.

The function will compute the scaling differences using only the specified subset of cells.
However, the re-scaling will then be applied to all cells in each batch - hence the extrapolation.
This means that the output is always of the same dimensionality, regardless of whether \code{restrict} is specified.
}

\examples{
means <- 2^rgamma(1000, 2, 1)
A1 <- matrix(rpois(10000, lambda=means), ncol=50) # Batch 1 
A2 <- matrix(rpois(10000, lambda=means*runif(1000, 0, 2)), ncol=50) # Batch 2

B1 <- log2(A1 + 1)
B2 <- log2(A2 + 1)
out <- rescaleBatches(B1, B2) 

}
\author{
Aaron Lun
}
